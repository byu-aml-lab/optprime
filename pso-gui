#!/usr/bin/env python

from __future__ import division
from sets import Set
from itertools import izip

# General GUI imports
import wx

# Generated by wxGlade
from psoframe import psoframe

# Remaining imports
from simulation import Simulation
from simulation import motions, neighborhoods, functions
from simulation import motionlist, neighborhoodlist, functionlist

#------------------------------------------------------------------------------
class ParticleCanvas(object):
    """Creates a canvas on which to draw the particles."""
    def __init__( self, simulation, particles, size ):
        self.size = size
        self.simulation = simulation
        self.buffer = wx.EmptyBitmap( size.GetWidth(), size.GetHeight() )
        dc = self.bufferdc = wx.BufferedDC(None, self.buffer)
        dc.SetBackground(wx.Brush(wx.BLACK))
        dc.Clear()

    def sim2norm( self, coords ):
        """Convert simulation coordiantes to normalized 0-1 coordinates"""
        # First we create function-boundary normalized coordinates (everything
        # between 0 and 1)
        func = self.simulation.func
        bounds = func.constraints[:2]
        if self.simulation.dims == 1:
            bounds = [bounds[0],(-1,1)]

        return [(c-cl)/abs(cr-cl) for c,(cl,cr) in izip(coords,bounds)]

    def norm2canvas( self, coords ):
        """Convert normalized coordinates to screen coordinates"""
        if len(coords) >= 2:
            nx, ny = coords
        else:
            nx = coords[0]
            ny = 0

        # Flip y upside down so that it works with normal cartesian visuals
        ny = 1 - ny

        # At least a certain percentage of the screen should be outside of the
        # simulation, if the simulation is not wrapped.
        if self.simulation.wrap:
            border = 0.0
        else:
            border = 0.4

        w, h = self.size.GetWidth(), self.size.GetHeight()

        rectside = min(w,h) * (1-border)

        # Now compute the x and y boundary rectangle
        xl = int((w - rectside) / 2)
        xr = w - xl
        yl = int((h - rectside) / 2)
        yr = h - yl

        # Now we can finally compute the actual pixel locations of the
        # normalized coordinates.
        return int(nx * (xr-xl) + xl), int(ny * (yr-yl) + yl)

    def sim2canvas( self, coords ):
        """Converts simulation coordinates to canvas coordinates"""
        return self.norm2canvas(self.sim2norm(coords))

    def draw_particles( self, particleiter ):
        sim = self.simulation
        dc = self.bufferdc

        linepen = wx.Pen(wx.NamedColour('GREEN'),1,wx.SOLID)
        linepen.SetWidth(2)
        pointpen = wx.Pen(wx.NamedColour('YELLOW'),1,wx.SOLID)
        pointpen.SetWidth(4)
        bestpen = wx.Pen(wx.NamedColour('RED'),1,wx.SOLID)
        bestpen.SetWidth(2)
        dc.SetPen(linepen)
        particles = list(particleiter)
        for p in particles:
            if sim.dims > 1:
                end = p.pos
                #start = p.lastpos
                start = (p.pos - p.vel)
            else:
                end = [p.pos[0],0.0]
                start = [p.pos[0] - p.vel[0],0.0]

            sx, sy = self.sim2canvas(start)
            ex, ey = self.sim2canvas(end)

            dc.DrawLine(sx, sy, ex, ey)
        dc.SetPen(pointpen)
        for p in particles:
            if sim.dims > 1:
                end = p.pos
            else:
                end = [p.pos[0],0.0]
            ex, ey = self.sim2canvas(end)
            dc.DrawEllipse(ex-1, ey-1,3,3)
        dc.SetPen(bestpen)
        for p in particles:
            if sim.dims > 1:
                end = p.bestpos
            else:
                end = [p.bestpos[0],0.0]
            x, y = self.sim2canvas(end)
            dc.DrawLine(x-1,y,x+1,y)
            dc.DrawLine(x,y-1,x,y+1)

    def draw_rect_from_constraints( self, constraints, color, shrink=0 ):
        s2c = self.sim2canvas

        dc = self.bufferdc
        dc.SetPen(wx.Pen(wx.NamedColour(color)))
        dc.BeginDrawing()
        upperleft, lowerright = zip(*constraints)
        upperleft = list(s2c(upperleft))
        lowerright = list(s2c(lowerright))
        for i, (ul,lr) in enumerate(izip(upperleft, lowerright)):
            if ul >= lr:
                upperleft[i] = lr
                lowerright[i] = ul
            if shrink:
                upperleft[i] += shrink
                lowerright[i] -= shrink

        # The rectangle function appears to be broken....
        dc.DrawLine(upperleft[0],upperleft[1],lowerright[0],upperleft[1])
        dc.DrawLine(upperleft[0],lowerright[1],lowerright[0],lowerright[1])
        dc.DrawLine(upperleft[0],upperleft[1],upperleft[0],lowerright[1])
        dc.DrawLine(lowerright[0],upperleft[1],lowerright[0],lowerright[1])
        dc.EndDrawing()

    def draw_tree( self, tree, color="BLUE" ):
        dc = self.bufferdc
        #dc.SetTextForeground( color )
        for n in tree.iterleaves():
            self.draw_rect_from_constraints( n.constraints, color )
            #midpoint = s2c([(cl+cr)/2 for cl, cr in n.constraints])
            #dc.BeginDrawing()
            #dc.DrawText(str(n.depth), midpoint[0],midpoint[1])
            #dc.EndDrawing()

    def draw_center( self ):
        dc = self.bufferdc
        cfunc = self.simulation.func.abscenter
        if self.simulation.dims == 1:
            cfunc = [cfunc[0],0.0]
        cx, cy = self.sim2canvas( cfunc )
        dc.SetPen(wx.Pen(wx.NamedColour('YELLOW'),1,wx.DOT))
        radius = 8
        dc.DrawEllipse( cx-radius, cy-radius, radius*2, radius * 2 )
        #dc.SetPen(wx.Pen(wx.NamedColour('YELLOW'),2,wx.DOT))
        dc.DrawLine(cx-radius,cy,cx+radius,cy)
        dc.DrawLine(cx,cy-radius,cx,cy+radius)

    def draw_border( self ):
        dc = self.bufferdc
        dc.SetPen(wx.Pen(wx.BLUE,1,wx.SOLID))
        dc.SetBrush(wx.Brush(wx.BLACK, wx.TRANSPARENT))

        x1,y1 = self.norm2canvas((0,0))
        x2,y2 = self.norm2canvas((1,1))

        dc.DrawRectangle(x1,y1,x2-x1,y2-y1)

    def update( self, particleiter ):
        """Updates the state of the canvas to reflect the simulation"""
        dc = self.bufferdc
        sim = self.simulation

        dc.BeginDrawing()
        dc.Clear()
        if hasattr(sim, 'tree'):
            self.draw_tree( sim.tree )
        self.draw_border()
        self.draw_center()
        self.draw_particles( particleiter )
        dc.EndDrawing()

    def blit( self, window ):
        wx.BufferedPaintDC( window, self.buffer )

#------------------------------------------------------------------------------
class MainFrame(psoframe):
    def __init__( self, size=(800,600), **kargs ):
        psoframe.__init__( self, None, -1, "PSO" )
        self.SetSize(size)

        self.numparts = 5
        self.dimensions = 2

        # Here we populate the controls on each panel of the notebook.
        self.__populate_controls()

        wx.EVT_PAINT( self.panel_view, self.on_view_paint )
        wx.EVT_PAINT( self, self.on_paint )
        wx.EVT_SIZE( self, self.on_size )
        wx.EVT_IDLE( self, self.on_idle )

        wx.EVT_MENU( self, self.exit.GetId(), self.on_exit )
        wx.EVT_BUTTON( self, self.button_start.GetId(), self.on_start )
        wx.EVT_COMMAND_SCROLL( self,
                self.slider_numparts.GetId(),
                self.on_scroll_parts
                )
        wx.EVT_COMMAND_SCROLL( self,
                self.slider_dimensions.GetId(),
                self.on_scroll_dimension
                )
        wx.EVT_CHOICE( self,
                self.choice_function.GetId(),
                self.on_choice_function
                )
        wx.EVT_CHOICE( self,
                self.choice_motion.GetId(),
                self.on_choice_motion
                )
        wx.EVT_CHOICE( self,
                self.choice_sociometry.GetId(),
                self.on_choice_sociometry
                )

        self.choice_function.SetSelection(0)
        name = self.get_function().__name__
        self.set_enabled_controls( name, self.panel_ctrl_function )

        self.choice_motion.SetSelection(0)
        name = self.get_motion().__name__
        self.set_enabled_controls( name, self.panel_ctrl_motion )

        self.choice_sociometry.SetSelection(0)
        name = self.get_sociometry().__name__
        self.set_enabled_controls( name, self.panel_ctrl_sociometry )

        # Set up an animation timer
        self.timer = wx.PyTimer( self.on_timer )
        self.interval = kargs.get('interval',100)

        # Empty simulation.  We'll create one after the controls exist and are
        # populated.
        self.canvas = None
        self.simulation = None
        self.soc = None
        self.reset_simulation = True

        # State of the simulation
        self.simulation_running = False

    def invalidate_simulation( self ):
        self.reset_simulation = True
        if self.button_start.GetLabel() == 'Pause':
            self.button_start.SetLabel( 'Stop' )
        elif self.button_start.GetLabel() == 'Continue':
            self.button_start.SetLabel( 'Start' )

    def get_function( self ):
        return functionlist[self.choice_function.GetSelection()]

    def get_motion( self ):
        return motionlist[self.choice_motion.GetSelection()]

    def get_sociometry( self ):
        return neighborhoodlist[self.choice_sociometry.GetSelection()]

    def __populate_controls( self ):
        self.slider_numparts.SetValue( self.numparts )
        self.slider_dimensions.SetValue( self.dimensions )

        for cls in functionlist:
            self.choice_function.Append(cls.__name__)
        sizer = self.notebook_ctrl_pane_function.GetSizer()
        sizer.Fit(self.notebook_ctrl_pane_function)

        for cls in motionlist:
            self.choice_motion.Append(cls.__name__)
        sizer = self.notebook_ctrl_pane_motion.GetSizer()
        sizer.Fit(self.notebook_ctrl_pane_motion)

        for cls in neighborhoodlist:
            self.choice_sociometry.Append(cls.__name__)
        sizer = self.notebook_ctrl_pane_sociometry.GetSizer()
        sizer.Fit(self.notebook_ctrl_pane_sociometry)
        
        # Create argument pointers for all useful values
        self.simargs = {}

        # Now we get to actually create all of the args components.
        self.generate_control_panel( self.panel_ctrl_function, functions )
        self.generate_control_panel( self.panel_ctrl_motion, motions )
        self.generate_control_panel( self.panel_ctrl_sociometry, neighborhoods )
        self.generate_simple_control_panel(
                self.panel_ctrl_simulation,
                Simulation
                )
        self.window_split.SizeWindows()
        self.update_choice_label()

    def control_pair_from_arg( self, window, arg ):
        if arg.converter is bool:
            ctrl = wx.CheckBox( window, wx.NewId(), arg.name, style=wx.EXPAND )
            ctrl.SetValue( bool(arg.default) )
            wx.EVT_CHECKBOX( self, ctrl.GetId(), self.on_check_change )
            text = None
        else:
            ctrl = wx.TextCtrl(
                    window, wx.NewId(), str(arg.default), style=wx.EXPAND )
            text = wx.StaticText(window, wx.NewId(), arg.name, style=wx.EXPAND)
            wx.EVT_TEXT( self, ctrl.GetId(), self.on_text_change )

        ctrl.arg_name = arg.name
        ctrl.SetToolTipString( arg.description )
        return text, ctrl

    def generate_simple_control_panel( self, window, cls ):
        sizer = wx.FlexGridSizer( cols=2 )
        singles = []
        used_text = False
        for aname, arg in cls.args.iteritems():
            text, control = self.control_pair_from_arg( window, arg )
            if text is not None:
                sizer.Add( text )
                sizer.Add( control )
                used_text = True
            else:
                singles.append( control )
            arg = arg.copy()
            self.simargs[aname] = arg
            arg.value = arg.converter(arg.default)
        for s in singles:
            sizer.Add( s )

        sizer.AddGrowableCol(1)
        if not used_text:
            sizer.AddGrowableCol(0)

        window.SetSizer( sizer )
        sizer.Fit(window)
        window.SetAutoLayout(True)

    def generate_control_panel( self, window, things ):
        # Generate a better data structure for handling this sort of thing
        args = {}
        for tname, thing in things.iteritems():
            for aname, arg in thing.args.iteritems():
                if aname == 'dims': continue
                if aname not in args:
                    args[aname] = [arg, [tname]]
                else:
                    args[aname][1].append( tname )

        # Now we create all of the necessary components in a list.
        sizer = wx.FlexGridSizer( cols=2 )
        used_text = False
        singles = []
        for aname, (arg, vlist) in args.iteritems():
            text, component = self.control_pair_from_arg( window, arg )
            if text is not None:
                # If we have used an odd number of spaces, we need to add a
                # blank text control to make the gridding work out.
                text.enabled_things = Set(vlist)
                sizer.Add( text )
                sizer.Add( component )
                used_text = True
            else:
                singles.append( component )
            component.enabled_things = Set(vlist)
            arg = arg.copy()
            self.simargs[aname] = arg
            arg.value = arg.converter(arg.default)
        for s in singles:
            sizer.Add( s )

        sizer.AddGrowableCol(1)
        if not used_text:
            sizer.AddGrowableCol(0)

        window.SetSizer( sizer )
        sizer.Fit( window )
        window.SetAutoLayout(True)

    def update_choice_label( self ):
        self.label_choices.SetLabel('%s : %s : %s' % (
            self.get_function().__name__,
            self.get_motion().__name__,
            self.get_sociometry().__name__,
            ))

    def generate_simulation( self ):
        fcls = self.get_function()
        mcls = self.get_motion()
        scls = self.get_sociometry()

        valdict = dict([(k, a.value) for k, a in self.simargs.iteritems()])
        valdict['dims'] = self.dimensions

        self.simulation = Simulation(
                self.numparts,
                self.get_sociometry(),
                self.get_function(),
                self.get_motion(),
                **valdict
                )

        self.simiter = self.simulation.iterbatches()
        self.soc, self.iters = self.simiter.next()

        # The canvas should always be regenerated when the simulation is
        # created since it depends on it.
        self.canvas = ParticleCanvas(
                self.simulation,
                list(self.soc.iterparticles()),
                self.panel_view.GetClientSize()
                )

    def set_enabled_controls( self, name, panel ):
        for c in panel.GetChildren():
            if hasattr(c, 'enabled_things'):
                c.Enable(name in c.enabled_things)

    def update_status_bar( self ):
        text = ['','']
        soc = self.soc
        if soc is not None:
            part = soc.bestparticle()
            pos = part.bestpos
            val = part.bestval
            fstr = "(" + ", ".join(['%r'] * min(2,len(pos))) + ")"
            text[1] = (fstr % tuple(pos[:2]))
            text[0] = "%d,%d: %r" % (soc.iters, soc.numparticles(), val)

        for i,t in enumerate(text):
            self.statusbar.SetStatusText(t,i)

    def on_check_change( self, event ):
        obj = event.GetEventObject()
        if hasattr(obj,'arg_name'):
            name = obj.arg_name
            checked = obj.GetValue()
            arg = self.simargs[name]
            arg.value = checked
        self.invalidate_simulation()

    def on_text_change( self, event ):
        obj = event.GetEventObject()
        if hasattr(obj,'arg_name'):
            name = obj.arg_name
            text = obj.GetValue()
            arg = self.simargs[name]
            if text:
                arg.value = arg.converter( eval(text) )
        self.invalidate_simulation()

    def on_exit( self, event ):
        self.Close()

    def on_start( self, event ):
        btn = event.GetEventObject()
        if self.simulation_running:
            # Running, so we pause or stop it
            self.timer.Stop()
            self.simulation_running = False
            btn.SetLabel('Start')
        else:
            # Not running, so we start or continue
            if self.reset_simulation:
                self.generate_simulation()
            self.canvas.update(self.soc.iterparticles())
            self.panel_view.Refresh(False)
            self.update_status_bar()
            btn.SetLabel( 'Stop' )
            self.simulation_running = True
            self.timer.Start()

    def on_timer( self ):
        self.timer.Stop()
        if self.canvas is not None:
            self.canvas.update(self.soc.iterparticles())
            self.panel_view.Refresh(False)
            self.update_status_bar()
        dummy, self.iters = self.simiter.next()
        self.timer.Start( self.interval )

    def on_scroll_parts( self, event ):
        self.numparts = event.GetInt()
        self.invalidate_simulation()

    def on_scroll_dimension( self, event ):
        self.dimensions = event.GetInt()
        self.invalidate_simulation()

    def on_choice_function( self, event ):
        self.update_choice_label()
        name = self.get_function().__name__
        self.set_enabled_controls( name, self.panel_ctrl_function )
        self.invalidate_simulation()

    def on_choice_motion( self, event ):
        self.update_choice_label()
        name = self.get_motion().__name__
        self.set_enabled_controls( name, self.panel_ctrl_motion )
        self.invalidate_simulation()

    def on_choice_sociometry( self, event ):
        self.update_choice_label()
        name = self.get_sociometry().__name__
        self.set_enabled_controls( name, self.panel_ctrl_sociometry )
        self.invalidate_simulation()

    def on_paint( self, event ):
        self.update_choice_label()

    def on_view_paint( self, event ):
        if self.canvas is not None:
            self.canvas.blit( self.panel_view )

    def on_size( self, event ):
        self.canvas = None

    def on_idle( self, event ):
        if self.canvas is None:
            size = self.panel_view.GetClientSize()
            if self.soc is not None:
                particles = list(self.soc.iterparticles())
            else:
                particles = None
            self.canvas = ParticleCanvas( self.simulation, particles, size )

#------------------------------------------------------------------------------
# MAIN
#------------------------------------------------------------------------------
if __name__ == '__main__':
    app = wx.PySimpleApp()
    frame = MainFrame()
    frame.Show(True)
    app.MainLoop()
#------------------------------------------------------------------------------
